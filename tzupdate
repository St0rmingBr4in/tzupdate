#!/usr/bin/env python

"""Automatically determine local time zone based on IP geolocation."""

import argparse
import httplib
import json
import os
import sys
import urllib


class MissingZoneInfoFile(Exception):
    """Raised when we can't find a timezone in our local zoneinfo database."""
    pass

def location_from_ip(ip=None):
    """
    Return location data for an IP using the IPInfoDB API.

    :param ip: IP address to get location for
    :returns: latitude and longitude
    """

    url = "http://api.ipinfodb.com/v3/ip-city/?"
    url_params = {
        "key": "c253fddcfa96b60155aa66fb51b20cba" \
               "dbcfa2020b2d27a89d4554ac2799b935",
        "format": "json",
    }

    if ip is not None:
        url_params["ip"] = ip

    res_handle = urllib.urlopen(url + urllib.urlencode(url_params))
    res_data = json.load(res_handle)

    return {
        "latitude": res_data["latitude"],
        "longitude": res_data["longitude"],
    }

class TZUpdate():
    """Automatically determine local time zone based on IP geolocation."""
    def __init__(self, localtime_path="/etc/localtime", zoneinfo_path="/usr/share/zoneinfo"):
        self.localtime_path = localtime_path
        self.zoneinfo_path = zoneinfo_path

        self.uris = {
            "geolocate": {
                "host": "api.ipinfodb.com",
                "path": "/v3/ip-city/?"
            },
            "timezone": {
                "host": "api.geonames.org",
                "path": "/timezoneJSON?"
            }
        }
        self.conns = self._connect()

    def _connect(self):
        """Connect to APIs."""
        connections = {}
        for k, v in self.uris.items():
            connections[k] = httplib.HTTPConnection(v["host"])
        return connections

    def tz_from_coords(self, latitude, longitude, user="tzupdate", **extras):
        """Get the timezone for a latitude/longitude."""
        self.conns["timezone"].request("GET", self.uris["timezone"]["path"] +
            urllib.urlencode({
                "lat":latitude,
                "lng":longitude,
                "username":user # Please be respectful and use your own username
                                # if you know you are going to make lots of
                                # API requests.
            })
        )
        ret = json.loads(self.conns["timezone"].getresponse().read())
        return ret["timezoneId"]

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("-d", "--dry-run", action="store_true", help="Don't update the localtime symlink")
    parser.add_argument("-i", "--ipinfodb-api-key", default="c253fddcfa96b60155aa66fb51b20cbadbcfa2020b2d27a89d4554ac2799b935", help="Override default API key for IPInfoDB")
    parser.add_argument("-u", "--geonames-username", default="tzupdate", help="Override default GeoNames username")
    parser.add_argument("-v", "--verbose", action="store_true", help="Print what we are doing")
    args = parser.parse_args()

    if args.verbose:
        def vprint(*args):
            print " ".join(args)
    else:
        vprint = lambda *args: None

    a = TZUpdate()

    vprint("Locating IP")
    geolocation_data = location_from_ip()
    vprint("Located at %(latitude)s, %(longitude)s" % geolocation_data)

    vprint("Getting timezone for coordinates")
    tz = a.tz_from_coords(**geolocation_data)
    vprint("Timezone is %s" % tz)

    tz_path = os.path.join(a.zoneinfo_path, tz)
    if not os.path.isfile(tz_path):
        raise MissingZoneInfoFile(tz)

    if args.dry_run:
        print "Exiting due to dry run"
        sys.exit(0)

    if os.path.exists(a.localtime_path):
        vprint("localtime file %s already exists, unlinking" % a.localtime_path)
        os.unlink(a.localtime_path)
    vprint("Symlinking %s to %s" % (a.localtime_path, tz_path))
    os.symlink(tz_path, a.localtime_path)
    print "Set timezone: %s" % tz
